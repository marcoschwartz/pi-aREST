diff --git a/lib/rpio.js b/lib/rpio.js
index b644c7a..ea10d45 100644
--- a/lib/rpio.js
+++ b/lib/rpio.js
@@ -522,9 +522,10 @@ rpio.prototype.open = function(pin, mode, init)
 
 	switch (mode) {
 	case rpio.prototype.INPUT:
+		bindcall2(binding.gpio_function, gpiopin, rpio.prototype.INPUT);
 		if (init !== undefined)
 			bindcall2(binding.gpio_pud, gpiopin, init);
-		return bindcall2(binding.gpio_function, gpiopin, rpio.prototype.INPUT);
+		return;
 	case rpio.prototype.OUTPUT:
 		if (init !== undefined)
 			bindcall2(binding.gpio_write, gpiopin, init);
diff --git a/src/bcm2835.c b/src/bcm2835.c
index 2d1f6c8..5f4c2cf 100644
--- a/src/bcm2835.c
+++ b/src/bcm2835.c
@@ -630,9 +630,10 @@ void bcm2835_gpio_set_pud(uint8_t pin, uint8_t pud)
     } else
     {
     bcm2835_gpio_pud(pud);
-    delayMicroseconds(10);
+    /* rpio patched to avoid requiring root access */
+    usleep(10);
     bcm2835_gpio_pudclk(pin, 1);
-    delayMicroseconds(10);
+    usleep(10);
     bcm2835_gpio_pud(BCM2835_GPIO_PUD_OFF);
     bcm2835_gpio_pudclk(pin, 0);
 }
diff --git a/src/rpio.cc b/src/rpio.cc
index 45159c0..3bf6f23 100644
--- a/src/rpio.cc
+++ b/src/rpio.cc
@@ -124,18 +124,7 @@ NAN_METHOD(gpio_pud)
 	uint32_t pin(Nan::To<uint32_t>(info[0]).FromJust());
 	uint32_t pud(Nan::To<uint32_t>(info[1]).FromJust());
 
-	/*
-	 * We use our own version of bcm2835_gpio_set_pud as that uses
-	 * delayMicroseconds() which requires access to the timers and
-	 * therefore /dev/mem and root.  Our version is identical, except for
-	 * using usleep() instead.
-	 */
-	bcm2835_gpio_pud(pud);
-	usleep(10);
-	bcm2835_gpio_pudclk(pin, 1);
-	usleep(10);
-	bcm2835_gpio_pud(BCM2835_GPIO_PUD_OFF);
-	bcm2835_gpio_pudclk(pin, 0);
+	bcm2835_gpio_set_pud(pin, pud);
 }
 
 NAN_METHOD(gpio_event_set)
